---
title: "Token Metadata"
description: "Add rich metadata to your compressed tokens"
---

## Overview

Token metadata provides essential information about your compressed tokens, including names, symbols, descriptions, and images. This guide covers how to create, manage, and query metadata for compressed tokens.

## Creating Token Metadata

### Basic Metadata Structure

Define metadata following the Metaplex Token Metadata standard:

```typescript
interface TokenMetadata {
  name: string;
  symbol: string;
  description: string;
  image: string;
  external_url?: string;
  attributes?: Array<{
    trait_type: string;
    value: string | number;
  }>;
  properties?: {
    files?: Array<{
      uri: string;
      type: string;
    }>;
    category?: string;
  };
}

const metadata: TokenMetadata = {
  name: "Compressed Gold Token",
  symbol: "cGOLD",
  description: "A compressed token representing digital gold",
  image: "https://example.com/images/gold-token.png",
  external_url: "https://example.com/tokens/cgold",
  attributes: [
    {
      trait_type: "Rarity",
      value: "Legendary",
    },
    {
      trait_type: "Purity",
      value: 99.9,
    },
  ],
  properties: {
    files: [
      {
        uri: "https://example.com/images/gold-token.png",
        type: "image/png",
      },
    ],
    category: "image",
  },
};
```

### Creating a Mint with Metadata

Create a compressed token mint with metadata:

```typescript
import {
  createMintWithMetadata,
  uploadMetadata,
} from "@lightprotocol/zk-compression-sdk";

async function createTokenWithMetadata(metadata: TokenMetadata) {
  // 1. Upload metadata to IPFS or Arweave
  const metadataUri = await uploadMetadata({
    metadata,
    storage: "ipfs", // or 'arweave'
  });

  console.log("ðŸ“„ Metadata uploaded to:", metadataUri);

  // 2. Create mint with metadata
  const mint = await createMintWithMetadata({
    connection,
    payer,
    mintAuthority: payer.publicKey,
    decimals: 9,
    metadata: {
      name: metadata.name,
      symbol: metadata.symbol,
      uri: metadataUri,
      sellerFeeBasisPoints: 500, // 5% royalty
      creators: [
        {
          address: payer.publicKey,
          verified: true,
          share: 100,
        },
      ],
    },
  });

  console.log("âœ… Created mint with metadata:", mint.toBase58());
  return { mint, metadataUri };
}
```

## Updating Metadata

### Update Existing Metadata

Update metadata for an existing compressed token:

```typescript
import { updateTokenMetadata } from "@lightprotocol/zk-compression-sdk";

async function updateMetadata(
  mint: PublicKey,
  newMetadata: Partial<TokenMetadata>
) {
  // 1. Get current metadata
  const currentMetadata = await getTokenMetadata({
    connection,
    mint,
  });

  // 2. Merge with new metadata
  const updatedMetadata = {
    ...currentMetadata,
    ...newMetadata,
  };

  // 3. Upload updated metadata
  const newMetadataUri = await uploadMetadata({
    metadata: updatedMetadata,
    storage: "ipfs",
  });

  // 4. Update on-chain metadata
  const signature = await updateTokenMetadata({
    connection,
    payer,
    mint,
    authority: payer,
    newUri: newMetadataUri,
  });

  console.log("âœ… Metadata updated:", signature);
  return newMetadataUri;
}
```

### Batch Metadata Updates

Update metadata for multiple tokens efficiently:

```typescript
async function batchUpdateMetadata(
  updates: Array<{
    mint: PublicKey;
    metadata: Partial<TokenMetadata>;
  }>
) {
  // Upload all metadata in parallel
  const uploadPromises = updates.map(async (update) => {
    const metadataUri = await uploadMetadata({
      metadata: update.metadata,
      storage: "ipfs",
    });

    return {
      mint: update.mint,
      metadataUri,
    };
  });

  const uploadResults = await Promise.all(uploadPromises);

  // Update on-chain metadata in batches
  const signature = await batchUpdateTokenMetadata({
    connection,
    payer,
    authority: payer,
    updates: uploadResults,
  });

  console.log(`âœ… Updated metadata for ${updates.length} tokens`);
  return signature;
}
```

## Querying Metadata

### Get Token Metadata

Retrieve metadata for a compressed token:

```typescript
import { getTokenMetadata } from "@lightprotocol/zk-compression-sdk";

async function getMetadata(mint: PublicKey) {
  try {
    // Get on-chain metadata account
    const metadataAccount = await getTokenMetadata({
      connection,
      mint,
    });

    console.log("On-chain metadata:", {
      name: metadataAccount.name,
      symbol: metadataAccount.symbol,
      uri: metadataAccount.uri,
    });

    // Fetch off-chain metadata
    const response = await fetch(metadataAccount.uri);
    const offChainMetadata = await response.json();

    console.log("Off-chain metadata:", offChainMetadata);

    return {
      onChain: metadataAccount,
      offChain: offChainMetadata,
    };
  } catch (error) {
    console.error("Error fetching metadata:", error);
    return null;
  }
}
```

### Search Tokens by Metadata

Search for tokens based on metadata attributes:

```typescript
import { searchTokensByMetadata } from "@lightprotocol/zk-compression-sdk";

async function searchTokens(criteria: {
  name?: string;
  symbol?: string;
  creator?: PublicKey;
  attributes?: Array<{
    trait_type: string;
    value: string | number;
  }>;
}) {
  const results = await searchTokensByMetadata({
    connection,
    criteria,
    limit: 100,
  });

  console.log(`Found ${results.length} matching tokens`);

  results.forEach((token, index) => {
    console.log(`Token ${index + 1}:`);
    console.log(`  Mint: ${token.mint}`);
    console.log(`  Name: ${token.metadata.name}`);
    console.log(`  Symbol: ${token.metadata.symbol}`);
  });

  return results;
}

// Example searches
await searchTokens({ symbol: "cGOLD" });
await searchTokens({ creator: payer.publicKey });
await searchTokens({
  attributes: [{ trait_type: "Rarity", value: "Legendary" }],
});
```

## Advanced Metadata Features

### Dynamic Metadata

Create metadata that changes based on token state:

```typescript
class DynamicMetadata {
  private baseMetadata: TokenMetadata;

  constructor(baseMetadata: TokenMetadata) {
    this.baseMetadata = baseMetadata;
  }

  async generateMetadata(
    mint: PublicKey,
    owner: PublicKey
  ): Promise<TokenMetadata> {
    // Get current token state
    const balance = await getCompressedTokenBalance({
      connection,
      mint,
      owner,
    });

    const accountHistory = await getCompressedAccountHistory({
      connection,
      accountHash: mint.toBase58(),
    });

    // Generate dynamic attributes
    const dynamicAttributes = [
      {
        trait_type: "Balance",
        value: balance / 10 ** 9,
      },
      {
        trait_type: "Transaction Count",
        value: accountHistory.length,
      },
      {
        trait_type: "Age (days)",
        value: Math.floor(
          (Date.now() - accountHistory[0]?.timestamp) / (1000 * 60 * 60 * 24)
        ),
      },
    ];

    return {
      ...this.baseMetadata,
      attributes: [
        ...(this.baseMetadata.attributes || []),
        ...dynamicAttributes,
      ],
    };
  }
}
```

### Metadata Validation

Validate metadata before uploading:

```typescript
import Ajv from "ajv";

const metadataSchema = {
  type: "object",
  required: ["name", "symbol", "description", "image"],
  properties: {
    name: {
      type: "string",
      minLength: 1,
      maxLength: 32,
    },
    symbol: {
      type: "string",
      minLength: 1,
      maxLength: 10,
    },
    description: {
      type: "string",
      maxLength: 500,
    },
    image: {
      type: "string",
      format: "uri",
    },
    external_url: {
      type: "string",
      format: "uri",
    },
    attributes: {
      type: "array",
      items: {
        type: "object",
        required: ["trait_type", "value"],
        properties: {
          trait_type: { type: "string" },
          value: { type: ["string", "number"] },
        },
      },
    },
  },
};

function validateMetadata(metadata: TokenMetadata): boolean {
  const ajv = new Ajv({ formats: require("ajv-formats") });
  const validate = ajv.compile(metadataSchema);

  const isValid = validate(metadata);

  if (!isValid) {
    console.error("Metadata validation errors:", validate.errors);
    return false;
  }

  console.log("âœ… Metadata is valid");
  return true;
}
```

## Storage Options

### IPFS Storage

Store metadata on IPFS for decentralization:

```typescript
import { create } from "ipfs-http-client";

class IPFSStorage {
  private client;

  constructor(url: string = "https://ipfs.infura.io:5001") {
    this.client = create({ url });
  }

  async uploadMetadata(metadata: TokenMetadata): Promise<string> {
    try {
      const result = await this.client.add(JSON.stringify(metadata, null, 2));

      const uri = `https://ipfs.io/ipfs/${result.cid}`;
      console.log("ðŸ“„ Uploaded to IPFS:", uri);

      return uri;
    } catch (error) {
      console.error("IPFS upload failed:", error);
      throw error;
    }
  }

  async uploadImage(imageBuffer: Buffer): Promise<string> {
    try {
      const result = await this.client.add(imageBuffer);
      return `https://ipfs.io/ipfs/${result.cid}`;
    } catch (error) {
      console.error("Image upload failed:", error);
      throw error;
    }
  }
}
```

### Arweave Storage

Store metadata on Arweave for permanent storage:

```typescript
import Arweave from "arweave";

class ArweaveStorage {
  private arweave;
  private wallet;

  constructor(walletKey: any) {
    this.arweave = Arweave.init({
      host: "arweave.net",
      port: 443,
      protocol: "https",
    });
    this.wallet = walletKey;
  }

  async uploadMetadata(metadata: TokenMetadata): Promise<string> {
    try {
      const transaction = await this.arweave.createTransaction(
        {
          data: JSON.stringify(metadata, null, 2),
        },
        this.wallet
      );

      transaction.addTag("Content-Type", "application/json");
      transaction.addTag("App-Name", "ZK-Compression-Token");

      await this.arweave.transactions.sign(transaction, this.wallet);
      await this.arweave.transactions.post(transaction);

      const uri = `https://arweave.net/${transaction.id}`;
      console.log("ðŸ“„ Uploaded to Arweave:", uri);

      return uri;
    } catch (error) {
      console.error("Arweave upload failed:", error);
      throw error;
    }
  }
}
```

## Best Practices

### 1. Metadata Design

- Keep names and symbols concise but descriptive
- Use high-quality images (minimum 512x512px)
- Include relevant attributes for discoverability
- Follow established metadata standards

### 2. Storage Considerations

- Use IPFS for decentralization and cost-effectiveness
- Use Arweave for permanent, immutable storage
- Always validate metadata before uploading
- Consider backup storage solutions

### 3. Performance Optimization

- Cache frequently accessed metadata
- Use CDNs for image delivery
- Implement lazy loading for metadata-heavy UIs
- Batch metadata operations when possible

## Next Steps

<CardGroup cols={2}>
  <Card title="API Reference" icon="code" href="/api-reference/json-rpc">
    Explore the complete API documentation
  </Card>
  <Card title="FAQ" icon="circle-question" href="/help/faq">
    Find answers to common questions
  </Card>
</CardGroup>{" "}
